package handlers

// Code generated by http://github.com/gojuno/minimock (3.0.2). DO NOT EDIT.

//go:generate minimock -i github.com/PhilLar/go-chi_example/handlers.PetStore -o ./pet_store_mock_test.go

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/PhilLar/go-chi_example/models"
	"github.com/gojuno/minimock/v3"
)

// PetStoreMock implements PetStore
type PetStoreMock struct {
	t minimock.Tester

	funcFilterPets          func(kind string, firstLetter string, underage int, overage int) (ppa1 []*models.Pet, err error)
	inspectFuncFilterPets   func(kind string, firstLetter string, underage int, overage int)
	afterFilterPetsCounter  uint64
	beforeFilterPetsCounter uint64
	FilterPetsMock          mPetStoreMockFilterPets

	funcInsertPet          func(age int, name string, kind string) (i1 int, err error)
	inspectFuncInsertPet   func(age int, name string, kind string)
	afterInsertPetCounter  uint64
	beforeInsertPetCounter uint64
	InsertPetMock          mPetStoreMockInsertPet

	funcListPets          func() (ppa1 []*models.Pet, err error)
	inspectFuncListPets   func()
	afterListPetsCounter  uint64
	beforeListPetsCounter uint64
	ListPetsMock          mPetStoreMockListPets

	funcRemoveAllPets          func() (err error)
	inspectFuncRemoveAllPets   func()
	afterRemoveAllPetsCounter  uint64
	beforeRemoveAllPetsCounter uint64
	RemoveAllPetsMock          mPetStoreMockRemoveAllPets
}

// NewPetStoreMock returns a mock for PetStore
func NewPetStoreMock(t minimock.Tester) *PetStoreMock {
	m := &PetStoreMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.FilterPetsMock = mPetStoreMockFilterPets{mock: m}
	m.FilterPetsMock.callArgs = []*PetStoreMockFilterPetsParams{}

	m.InsertPetMock = mPetStoreMockInsertPet{mock: m}
	m.InsertPetMock.callArgs = []*PetStoreMockInsertPetParams{}

	m.ListPetsMock = mPetStoreMockListPets{mock: m}

	m.RemoveAllPetsMock = mPetStoreMockRemoveAllPets{mock: m}

	return m
}

type mPetStoreMockFilterPets struct {
	mock               *PetStoreMock
	defaultExpectation *PetStoreMockFilterPetsExpectation
	expectations       []*PetStoreMockFilterPetsExpectation

	callArgs []*PetStoreMockFilterPetsParams
	mutex    sync.RWMutex
}

// PetStoreMockFilterPetsExpectation specifies expectation struct of the PetStore.FilterPets
type PetStoreMockFilterPetsExpectation struct {
	mock    *PetStoreMock
	params  *PetStoreMockFilterPetsParams
	results *PetStoreMockFilterPetsResults
	Counter uint64
}

// PetStoreMockFilterPetsParams contains parameters of the PetStore.FilterPets
type PetStoreMockFilterPetsParams struct {
	kind        string
	firstLetter string
	underage    int
	overage     int
}

// PetStoreMockFilterPetsResults contains results of the PetStore.FilterPets
type PetStoreMockFilterPetsResults struct {
	ppa1 []*models.Pet
	err  error
}

// Expect sets up expected params for PetStore.FilterPets
func (mmFilterPets *mPetStoreMockFilterPets) Expect(kind string, firstLetter string, underage int, overage int) *mPetStoreMockFilterPets {
	if mmFilterPets.mock.funcFilterPets != nil {
		mmFilterPets.mock.t.Fatalf("PetStoreMock.FilterPets mock is already set by Set")
	}

	if mmFilterPets.defaultExpectation == nil {
		mmFilterPets.defaultExpectation = &PetStoreMockFilterPetsExpectation{}
	}

	mmFilterPets.defaultExpectation.params = &PetStoreMockFilterPetsParams{kind, firstLetter, underage, overage}
	for _, e := range mmFilterPets.expectations {
		if minimock.Equal(e.params, mmFilterPets.defaultExpectation.params) {
			mmFilterPets.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFilterPets.defaultExpectation.params)
		}
	}

	return mmFilterPets
}

// Inspect accepts an inspector function that has same arguments as the PetStore.FilterPets
func (mmFilterPets *mPetStoreMockFilterPets) Inspect(f func(kind string, firstLetter string, underage int, overage int)) *mPetStoreMockFilterPets {
	if mmFilterPets.mock.inspectFuncFilterPets != nil {
		mmFilterPets.mock.t.Fatalf("Inspect function is already set for PetStoreMock.FilterPets")
	}

	mmFilterPets.mock.inspectFuncFilterPets = f

	return mmFilterPets
}

// Return sets up results that will be returned by PetStore.FilterPets
func (mmFilterPets *mPetStoreMockFilterPets) Return(ppa1 []*models.Pet, err error) *PetStoreMock {
	if mmFilterPets.mock.funcFilterPets != nil {
		mmFilterPets.mock.t.Fatalf("PetStoreMock.FilterPets mock is already set by Set")
	}

	if mmFilterPets.defaultExpectation == nil {
		mmFilterPets.defaultExpectation = &PetStoreMockFilterPetsExpectation{mock: mmFilterPets.mock}
	}
	mmFilterPets.defaultExpectation.results = &PetStoreMockFilterPetsResults{ppa1, err}
	return mmFilterPets.mock
}

//Set uses given function f to mock the PetStore.FilterPets method
func (mmFilterPets *mPetStoreMockFilterPets) Set(f func(kind string, firstLetter string, underage int, overage int) (ppa1 []*models.Pet, err error)) *PetStoreMock {
	if mmFilterPets.defaultExpectation != nil {
		mmFilterPets.mock.t.Fatalf("Default expectation is already set for the PetStore.FilterPets method")
	}

	if len(mmFilterPets.expectations) > 0 {
		mmFilterPets.mock.t.Fatalf("Some expectations are already set for the PetStore.FilterPets method")
	}

	mmFilterPets.mock.funcFilterPets = f
	return mmFilterPets.mock
}

// When sets expectation for the PetStore.FilterPets which will trigger the result defined by the following
// Then helper
func (mmFilterPets *mPetStoreMockFilterPets) When(kind string, firstLetter string, underage int, overage int) *PetStoreMockFilterPetsExpectation {
	if mmFilterPets.mock.funcFilterPets != nil {
		mmFilterPets.mock.t.Fatalf("PetStoreMock.FilterPets mock is already set by Set")
	}

	expectation := &PetStoreMockFilterPetsExpectation{
		mock:   mmFilterPets.mock,
		params: &PetStoreMockFilterPetsParams{kind, firstLetter, underage, overage},
	}
	mmFilterPets.expectations = append(mmFilterPets.expectations, expectation)
	return expectation
}

// Then sets up PetStore.FilterPets return parameters for the expectation previously defined by the When method
func (e *PetStoreMockFilterPetsExpectation) Then(ppa1 []*models.Pet, err error) *PetStoreMock {
	e.results = &PetStoreMockFilterPetsResults{ppa1, err}
	return e.mock
}

// FilterPets implements PetStore
func (mmFilterPets *PetStoreMock) FilterPets(kind string, firstLetter string, underage int, overage int) (ppa1 []*models.Pet, err error) {
	mm_atomic.AddUint64(&mmFilterPets.beforeFilterPetsCounter, 1)
	defer mm_atomic.AddUint64(&mmFilterPets.afterFilterPetsCounter, 1)

	if mmFilterPets.inspectFuncFilterPets != nil {
		mmFilterPets.inspectFuncFilterPets(kind, firstLetter, underage, overage)
	}

	mm_params := &PetStoreMockFilterPetsParams{kind, firstLetter, underage, overage}

	// Record call args
	mmFilterPets.FilterPetsMock.mutex.Lock()
	mmFilterPets.FilterPetsMock.callArgs = append(mmFilterPets.FilterPetsMock.callArgs, mm_params)
	mmFilterPets.FilterPetsMock.mutex.Unlock()

	for _, e := range mmFilterPets.FilterPetsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.err
		}
	}

	if mmFilterPets.FilterPetsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFilterPets.FilterPetsMock.defaultExpectation.Counter, 1)
		mm_want := mmFilterPets.FilterPetsMock.defaultExpectation.params
		mm_got := PetStoreMockFilterPetsParams{kind, firstLetter, underage, overage}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFilterPets.t.Errorf("PetStoreMock.FilterPets got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFilterPets.FilterPetsMock.defaultExpectation.results
		if mm_results == nil {
			mmFilterPets.t.Fatal("No results are set for the PetStoreMock.FilterPets")
		}
		return (*mm_results).ppa1, (*mm_results).err
	}
	if mmFilterPets.funcFilterPets != nil {
		return mmFilterPets.funcFilterPets(kind, firstLetter, underage, overage)
	}
	mmFilterPets.t.Fatalf("Unexpected call to PetStoreMock.FilterPets. %v %v %v %v", kind, firstLetter, underage, overage)
	return
}

// FilterPetsAfterCounter returns a count of finished PetStoreMock.FilterPets invocations
func (mmFilterPets *PetStoreMock) FilterPetsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFilterPets.afterFilterPetsCounter)
}

// FilterPetsBeforeCounter returns a count of PetStoreMock.FilterPets invocations
func (mmFilterPets *PetStoreMock) FilterPetsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFilterPets.beforeFilterPetsCounter)
}

// Calls returns a list of arguments used in each call to PetStoreMock.FilterPets.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFilterPets *mPetStoreMockFilterPets) Calls() []*PetStoreMockFilterPetsParams {
	mmFilterPets.mutex.RLock()

	argCopy := make([]*PetStoreMockFilterPetsParams, len(mmFilterPets.callArgs))
	copy(argCopy, mmFilterPets.callArgs)

	mmFilterPets.mutex.RUnlock()

	return argCopy
}

// MinimockFilterPetsDone returns true if the count of the FilterPets invocations corresponds
// the number of defined expectations
func (m *PetStoreMock) MinimockFilterPetsDone() bool {
	for _, e := range m.FilterPetsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FilterPetsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFilterPetsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFilterPets != nil && mm_atomic.LoadUint64(&m.afterFilterPetsCounter) < 1 {
		return false
	}
	return true
}

// MinimockFilterPetsInspect logs each unmet expectation
func (m *PetStoreMock) MinimockFilterPetsInspect() {
	for _, e := range m.FilterPetsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PetStoreMock.FilterPets with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FilterPetsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFilterPetsCounter) < 1 {
		if m.FilterPetsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PetStoreMock.FilterPets")
		} else {
			m.t.Errorf("Expected call to PetStoreMock.FilterPets with params: %#v", *m.FilterPetsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFilterPets != nil && mm_atomic.LoadUint64(&m.afterFilterPetsCounter) < 1 {
		m.t.Error("Expected call to PetStoreMock.FilterPets")
	}
}

type mPetStoreMockInsertPet struct {
	mock               *PetStoreMock
	defaultExpectation *PetStoreMockInsertPetExpectation
	expectations       []*PetStoreMockInsertPetExpectation

	callArgs []*PetStoreMockInsertPetParams
	mutex    sync.RWMutex
}

// PetStoreMockInsertPetExpectation specifies expectation struct of the PetStore.InsertPet
type PetStoreMockInsertPetExpectation struct {
	mock    *PetStoreMock
	params  *PetStoreMockInsertPetParams
	results *PetStoreMockInsertPetResults
	Counter uint64
}

// PetStoreMockInsertPetParams contains parameters of the PetStore.InsertPet
type PetStoreMockInsertPetParams struct {
	age  int
	name string
	kind string
}

// PetStoreMockInsertPetResults contains results of the PetStore.InsertPet
type PetStoreMockInsertPetResults struct {
	i1  int
	err error
}

// Expect sets up expected params for PetStore.InsertPet
func (mmInsertPet *mPetStoreMockInsertPet) Expect(age int, name string, kind string) *mPetStoreMockInsertPet {
	if mmInsertPet.mock.funcInsertPet != nil {
		mmInsertPet.mock.t.Fatalf("PetStoreMock.InsertPet mock is already set by Set")
	}

	if mmInsertPet.defaultExpectation == nil {
		mmInsertPet.defaultExpectation = &PetStoreMockInsertPetExpectation{}
	}

	mmInsertPet.defaultExpectation.params = &PetStoreMockInsertPetParams{age, name, kind}
	for _, e := range mmInsertPet.expectations {
		if minimock.Equal(e.params, mmInsertPet.defaultExpectation.params) {
			mmInsertPet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsertPet.defaultExpectation.params)
		}
	}

	return mmInsertPet
}

// Inspect accepts an inspector function that has same arguments as the PetStore.InsertPet
func (mmInsertPet *mPetStoreMockInsertPet) Inspect(f func(age int, name string, kind string)) *mPetStoreMockInsertPet {
	if mmInsertPet.mock.inspectFuncInsertPet != nil {
		mmInsertPet.mock.t.Fatalf("Inspect function is already set for PetStoreMock.InsertPet")
	}

	mmInsertPet.mock.inspectFuncInsertPet = f

	return mmInsertPet
}

// Return sets up results that will be returned by PetStore.InsertPet
func (mmInsertPet *mPetStoreMockInsertPet) Return(i1 int, err error) *PetStoreMock {
	if mmInsertPet.mock.funcInsertPet != nil {
		mmInsertPet.mock.t.Fatalf("PetStoreMock.InsertPet mock is already set by Set")
	}

	if mmInsertPet.defaultExpectation == nil {
		mmInsertPet.defaultExpectation = &PetStoreMockInsertPetExpectation{mock: mmInsertPet.mock}
	}
	mmInsertPet.defaultExpectation.results = &PetStoreMockInsertPetResults{i1, err}
	return mmInsertPet.mock
}

//Set uses given function f to mock the PetStore.InsertPet method
func (mmInsertPet *mPetStoreMockInsertPet) Set(f func(age int, name string, kind string) (i1 int, err error)) *PetStoreMock {
	if mmInsertPet.defaultExpectation != nil {
		mmInsertPet.mock.t.Fatalf("Default expectation is already set for the PetStore.InsertPet method")
	}

	if len(mmInsertPet.expectations) > 0 {
		mmInsertPet.mock.t.Fatalf("Some expectations are already set for the PetStore.InsertPet method")
	}

	mmInsertPet.mock.funcInsertPet = f
	return mmInsertPet.mock
}

// When sets expectation for the PetStore.InsertPet which will trigger the result defined by the following
// Then helper
func (mmInsertPet *mPetStoreMockInsertPet) When(age int, name string, kind string) *PetStoreMockInsertPetExpectation {
	if mmInsertPet.mock.funcInsertPet != nil {
		mmInsertPet.mock.t.Fatalf("PetStoreMock.InsertPet mock is already set by Set")
	}

	expectation := &PetStoreMockInsertPetExpectation{
		mock:   mmInsertPet.mock,
		params: &PetStoreMockInsertPetParams{age, name, kind},
	}
	mmInsertPet.expectations = append(mmInsertPet.expectations, expectation)
	return expectation
}

// Then sets up PetStore.InsertPet return parameters for the expectation previously defined by the When method
func (e *PetStoreMockInsertPetExpectation) Then(i1 int, err error) *PetStoreMock {
	e.results = &PetStoreMockInsertPetResults{i1, err}
	return e.mock
}

// InsertPet implements PetStore
func (mmInsertPet *PetStoreMock) InsertPet(age int, name string, kind string) (i1 int, err error) {
	mm_atomic.AddUint64(&mmInsertPet.beforeInsertPetCounter, 1)
	defer mm_atomic.AddUint64(&mmInsertPet.afterInsertPetCounter, 1)

	if mmInsertPet.inspectFuncInsertPet != nil {
		mmInsertPet.inspectFuncInsertPet(age, name, kind)
	}

	mm_params := &PetStoreMockInsertPetParams{age, name, kind}

	// Record call args
	mmInsertPet.InsertPetMock.mutex.Lock()
	mmInsertPet.InsertPetMock.callArgs = append(mmInsertPet.InsertPetMock.callArgs, mm_params)
	mmInsertPet.InsertPetMock.mutex.Unlock()

	for _, e := range mmInsertPet.InsertPetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmInsertPet.InsertPetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsertPet.InsertPetMock.defaultExpectation.Counter, 1)
		mm_want := mmInsertPet.InsertPetMock.defaultExpectation.params
		mm_got := PetStoreMockInsertPetParams{age, name, kind}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsertPet.t.Errorf("PetStoreMock.InsertPet got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsertPet.InsertPetMock.defaultExpectation.results
		if mm_results == nil {
			mmInsertPet.t.Fatal("No results are set for the PetStoreMock.InsertPet")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmInsertPet.funcInsertPet != nil {
		return mmInsertPet.funcInsertPet(age, name, kind)
	}
	mmInsertPet.t.Fatalf("Unexpected call to PetStoreMock.InsertPet. %v %v %v", age, name, kind)
	return
}

// InsertPetAfterCounter returns a count of finished PetStoreMock.InsertPet invocations
func (mmInsertPet *PetStoreMock) InsertPetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertPet.afterInsertPetCounter)
}

// InsertPetBeforeCounter returns a count of PetStoreMock.InsertPet invocations
func (mmInsertPet *PetStoreMock) InsertPetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertPet.beforeInsertPetCounter)
}

// Calls returns a list of arguments used in each call to PetStoreMock.InsertPet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsertPet *mPetStoreMockInsertPet) Calls() []*PetStoreMockInsertPetParams {
	mmInsertPet.mutex.RLock()

	argCopy := make([]*PetStoreMockInsertPetParams, len(mmInsertPet.callArgs))
	copy(argCopy, mmInsertPet.callArgs)

	mmInsertPet.mutex.RUnlock()

	return argCopy
}

// MinimockInsertPetDone returns true if the count of the InsertPet invocations corresponds
// the number of defined expectations
func (m *PetStoreMock) MinimockInsertPetDone() bool {
	for _, e := range m.InsertPetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertPetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertPetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertPet != nil && mm_atomic.LoadUint64(&m.afterInsertPetCounter) < 1 {
		return false
	}
	return true
}

// MinimockInsertPetInspect logs each unmet expectation
func (m *PetStoreMock) MinimockInsertPetInspect() {
	for _, e := range m.InsertPetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PetStoreMock.InsertPet with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertPetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertPetCounter) < 1 {
		if m.InsertPetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PetStoreMock.InsertPet")
		} else {
			m.t.Errorf("Expected call to PetStoreMock.InsertPet with params: %#v", *m.InsertPetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertPet != nil && mm_atomic.LoadUint64(&m.afterInsertPetCounter) < 1 {
		m.t.Error("Expected call to PetStoreMock.InsertPet")
	}
}

type mPetStoreMockListPets struct {
	mock               *PetStoreMock
	defaultExpectation *PetStoreMockListPetsExpectation
	expectations       []*PetStoreMockListPetsExpectation
}

// PetStoreMockListPetsExpectation specifies expectation struct of the PetStore.ListPets
type PetStoreMockListPetsExpectation struct {
	mock *PetStoreMock

	results *PetStoreMockListPetsResults
	Counter uint64
}

// PetStoreMockListPetsResults contains results of the PetStore.ListPets
type PetStoreMockListPetsResults struct {
	ppa1 []*models.Pet
	err  error
}

// Expect sets up expected params for PetStore.ListPets
func (mmListPets *mPetStoreMockListPets) Expect() *mPetStoreMockListPets {
	if mmListPets.mock.funcListPets != nil {
		mmListPets.mock.t.Fatalf("PetStoreMock.ListPets mock is already set by Set")
	}

	if mmListPets.defaultExpectation == nil {
		mmListPets.defaultExpectation = &PetStoreMockListPetsExpectation{}
	}

	return mmListPets
}

// Inspect accepts an inspector function that has same arguments as the PetStore.ListPets
func (mmListPets *mPetStoreMockListPets) Inspect(f func()) *mPetStoreMockListPets {
	if mmListPets.mock.inspectFuncListPets != nil {
		mmListPets.mock.t.Fatalf("Inspect function is already set for PetStoreMock.ListPets")
	}

	mmListPets.mock.inspectFuncListPets = f

	return mmListPets
}

// Return sets up results that will be returned by PetStore.ListPets
func (mmListPets *mPetStoreMockListPets) Return(ppa1 []*models.Pet, err error) *PetStoreMock {
	if mmListPets.mock.funcListPets != nil {
		mmListPets.mock.t.Fatalf("PetStoreMock.ListPets mock is already set by Set")
	}

	if mmListPets.defaultExpectation == nil {
		mmListPets.defaultExpectation = &PetStoreMockListPetsExpectation{mock: mmListPets.mock}
	}
	mmListPets.defaultExpectation.results = &PetStoreMockListPetsResults{ppa1, err}
	return mmListPets.mock
}

//Set uses given function f to mock the PetStore.ListPets method
func (mmListPets *mPetStoreMockListPets) Set(f func() (ppa1 []*models.Pet, err error)) *PetStoreMock {
	if mmListPets.defaultExpectation != nil {
		mmListPets.mock.t.Fatalf("Default expectation is already set for the PetStore.ListPets method")
	}

	if len(mmListPets.expectations) > 0 {
		mmListPets.mock.t.Fatalf("Some expectations are already set for the PetStore.ListPets method")
	}

	mmListPets.mock.funcListPets = f
	return mmListPets.mock
}

// ListPets implements PetStore
func (mmListPets *PetStoreMock) ListPets() (ppa1 []*models.Pet, err error) {
	mm_atomic.AddUint64(&mmListPets.beforeListPetsCounter, 1)
	defer mm_atomic.AddUint64(&mmListPets.afterListPetsCounter, 1)

	if mmListPets.inspectFuncListPets != nil {
		mmListPets.inspectFuncListPets()
	}

	if mmListPets.ListPetsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPets.ListPetsMock.defaultExpectation.Counter, 1)

		mm_results := mmListPets.ListPetsMock.defaultExpectation.results
		if mm_results == nil {
			mmListPets.t.Fatal("No results are set for the PetStoreMock.ListPets")
		}
		return (*mm_results).ppa1, (*mm_results).err
	}
	if mmListPets.funcListPets != nil {
		return mmListPets.funcListPets()
	}
	mmListPets.t.Fatalf("Unexpected call to PetStoreMock.ListPets.")
	return
}

// ListPetsAfterCounter returns a count of finished PetStoreMock.ListPets invocations
func (mmListPets *PetStoreMock) ListPetsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPets.afterListPetsCounter)
}

// ListPetsBeforeCounter returns a count of PetStoreMock.ListPets invocations
func (mmListPets *PetStoreMock) ListPetsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPets.beforeListPetsCounter)
}

// MinimockListPetsDone returns true if the count of the ListPets invocations corresponds
// the number of defined expectations
func (m *PetStoreMock) MinimockListPetsDone() bool {
	for _, e := range m.ListPetsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListPetsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListPetsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPets != nil && mm_atomic.LoadUint64(&m.afterListPetsCounter) < 1 {
		return false
	}
	return true
}

// MinimockListPetsInspect logs each unmet expectation
func (m *PetStoreMock) MinimockListPetsInspect() {
	for _, e := range m.ListPetsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to PetStoreMock.ListPets")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListPetsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListPetsCounter) < 1 {
		m.t.Error("Expected call to PetStoreMock.ListPets")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPets != nil && mm_atomic.LoadUint64(&m.afterListPetsCounter) < 1 {
		m.t.Error("Expected call to PetStoreMock.ListPets")
	}
}

type mPetStoreMockRemoveAllPets struct {
	mock               *PetStoreMock
	defaultExpectation *PetStoreMockRemoveAllPetsExpectation
	expectations       []*PetStoreMockRemoveAllPetsExpectation
}

// PetStoreMockRemoveAllPetsExpectation specifies expectation struct of the PetStore.RemoveAllPets
type PetStoreMockRemoveAllPetsExpectation struct {
	mock *PetStoreMock

	results *PetStoreMockRemoveAllPetsResults
	Counter uint64
}

// PetStoreMockRemoveAllPetsResults contains results of the PetStore.RemoveAllPets
type PetStoreMockRemoveAllPetsResults struct {
	err error
}

// Expect sets up expected params for PetStore.RemoveAllPets
func (mmRemoveAllPets *mPetStoreMockRemoveAllPets) Expect() *mPetStoreMockRemoveAllPets {
	if mmRemoveAllPets.mock.funcRemoveAllPets != nil {
		mmRemoveAllPets.mock.t.Fatalf("PetStoreMock.RemoveAllPets mock is already set by Set")
	}

	if mmRemoveAllPets.defaultExpectation == nil {
		mmRemoveAllPets.defaultExpectation = &PetStoreMockRemoveAllPetsExpectation{}
	}

	return mmRemoveAllPets
}

// Inspect accepts an inspector function that has same arguments as the PetStore.RemoveAllPets
func (mmRemoveAllPets *mPetStoreMockRemoveAllPets) Inspect(f func()) *mPetStoreMockRemoveAllPets {
	if mmRemoveAllPets.mock.inspectFuncRemoveAllPets != nil {
		mmRemoveAllPets.mock.t.Fatalf("Inspect function is already set for PetStoreMock.RemoveAllPets")
	}

	mmRemoveAllPets.mock.inspectFuncRemoveAllPets = f

	return mmRemoveAllPets
}

// Return sets up results that will be returned by PetStore.RemoveAllPets
func (mmRemoveAllPets *mPetStoreMockRemoveAllPets) Return(err error) *PetStoreMock {
	if mmRemoveAllPets.mock.funcRemoveAllPets != nil {
		mmRemoveAllPets.mock.t.Fatalf("PetStoreMock.RemoveAllPets mock is already set by Set")
	}

	if mmRemoveAllPets.defaultExpectation == nil {
		mmRemoveAllPets.defaultExpectation = &PetStoreMockRemoveAllPetsExpectation{mock: mmRemoveAllPets.mock}
	}
	mmRemoveAllPets.defaultExpectation.results = &PetStoreMockRemoveAllPetsResults{err}
	return mmRemoveAllPets.mock
}

//Set uses given function f to mock the PetStore.RemoveAllPets method
func (mmRemoveAllPets *mPetStoreMockRemoveAllPets) Set(f func() (err error)) *PetStoreMock {
	if mmRemoveAllPets.defaultExpectation != nil {
		mmRemoveAllPets.mock.t.Fatalf("Default expectation is already set for the PetStore.RemoveAllPets method")
	}

	if len(mmRemoveAllPets.expectations) > 0 {
		mmRemoveAllPets.mock.t.Fatalf("Some expectations are already set for the PetStore.RemoveAllPets method")
	}

	mmRemoveAllPets.mock.funcRemoveAllPets = f
	return mmRemoveAllPets.mock
}

// RemoveAllPets implements PetStore
func (mmRemoveAllPets *PetStoreMock) RemoveAllPets() (err error) {
	mm_atomic.AddUint64(&mmRemoveAllPets.beforeRemoveAllPetsCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveAllPets.afterRemoveAllPetsCounter, 1)

	if mmRemoveAllPets.inspectFuncRemoveAllPets != nil {
		mmRemoveAllPets.inspectFuncRemoveAllPets()
	}

	if mmRemoveAllPets.RemoveAllPetsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveAllPets.RemoveAllPetsMock.defaultExpectation.Counter, 1)

		mm_results := mmRemoveAllPets.RemoveAllPetsMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveAllPets.t.Fatal("No results are set for the PetStoreMock.RemoveAllPets")
		}
		return (*mm_results).err
	}
	if mmRemoveAllPets.funcRemoveAllPets != nil {
		return mmRemoveAllPets.funcRemoveAllPets()
	}
	mmRemoveAllPets.t.Fatalf("Unexpected call to PetStoreMock.RemoveAllPets.")
	return
}

// RemoveAllPetsAfterCounter returns a count of finished PetStoreMock.RemoveAllPets invocations
func (mmRemoveAllPets *PetStoreMock) RemoveAllPetsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveAllPets.afterRemoveAllPetsCounter)
}

// RemoveAllPetsBeforeCounter returns a count of PetStoreMock.RemoveAllPets invocations
func (mmRemoveAllPets *PetStoreMock) RemoveAllPetsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveAllPets.beforeRemoveAllPetsCounter)
}

// MinimockRemoveAllPetsDone returns true if the count of the RemoveAllPets invocations corresponds
// the number of defined expectations
func (m *PetStoreMock) MinimockRemoveAllPetsDone() bool {
	for _, e := range m.RemoveAllPetsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveAllPetsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveAllPetsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveAllPets != nil && mm_atomic.LoadUint64(&m.afterRemoveAllPetsCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemoveAllPetsInspect logs each unmet expectation
func (m *PetStoreMock) MinimockRemoveAllPetsInspect() {
	for _, e := range m.RemoveAllPetsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to PetStoreMock.RemoveAllPets")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveAllPetsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveAllPetsCounter) < 1 {
		m.t.Error("Expected call to PetStoreMock.RemoveAllPets")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveAllPets != nil && mm_atomic.LoadUint64(&m.afterRemoveAllPetsCounter) < 1 {
		m.t.Error("Expected call to PetStoreMock.RemoveAllPets")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PetStoreMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockFilterPetsInspect()

		m.MinimockInsertPetInspect()

		m.MinimockListPetsInspect()

		m.MinimockRemoveAllPetsInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PetStoreMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PetStoreMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockFilterPetsDone() &&
		m.MinimockInsertPetDone() &&
		m.MinimockListPetsDone() &&
		m.MinimockRemoveAllPetsDone()
}
